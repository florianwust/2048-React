<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="Content-Security-Policy" content="default-src 'self' data: gap: https://ssl.gstatic.com 'unsafe-eval'; style-src 'self' 'unsafe-inline'; media-src *">
        <meta name="format-detection" content="telephone=no">
        <meta name="msapplication-tap-highlight" content="no">
        <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width">
        <title>2048 React</title>
        <script src="js/react.js"></script>
        <script src="js/react-dom.js"></script>
        <script src="js/browser.min.js"></script>
        <script src="js/lodash.js"></script>
        <script src="js/jquery-2.2.0.min.js"></script>
        <script type="text/javascript" src="cordova.js"></script>
        <link rel="stylesheet" href="css/main.css">
    </head>
    <body>
		<div id="game" class="container"></div>
        <script type="text/babel">
            var Swipeable = React.createClass({displayName: "Swipeable",
  propTypes: {
    onSwiped: React.PropTypes.func,
    onSwiping: React.PropTypes.func,
    onSwipingUp: React.PropTypes.func,
    onSwipingRight: React.PropTypes.func,
    onSwipingDown: React.PropTypes.func,
    onSwipingLeft: React.PropTypes.func,
    onSwipedUp: React.PropTypes.func,
    onSwipedRight: React.PropTypes.func,
    onSwipedDown: React.PropTypes.func,
    onSwipedLeft: React.PropTypes.func,
    flickThreshold: React.PropTypes.number,
    delta: React.PropTypes.number
  },

  getInitialState: function () {
    return {
      x: null,
      y: null,
      swiping: false,
      start: 0
    }
  },

  getDefaultProps: function () {
    return {
      flickThreshold: 0.6,
      delta: 10
    }
  },

  calculatePos: function (e) {
    var x = e.changedTouches[0].clientX
    var y = e.changedTouches[0].clientY

    var xd = this.state.x - x
    var yd = this.state.y - y

    var axd = Math.abs(xd)
    var ayd = Math.abs(yd)

    return {
      deltaX: xd,
      deltaY: yd,
      absX: axd,
      absY: ayd
    }
  },

  touchStart: function (e) {
    if (e.touches.length > 1) {
      return
    }
    this.setState({
      start: Date.now(),
      x: e.touches[0].clientX,
      y: e.touches[0].clientY,
      swiping: false
    })
  },

  touchMove: function (e) {
    if (!this.state.x || !this.state.y || e.touches.length > 1) {
      return
    }

    var cancelPageSwipe = false
    var pos = this.calculatePos(e)

    if (pos.absX < this.props.delta && pos.absY < this.props.delta) {
      return
    }

    if (this.props.onSwiping) {
      this.props.onSwiping(e, pos.deltaX, pos.deltaY, pos.absX, pos.absY)
    }

    if (pos.absX > pos.absY) {
      if (pos.deltaX > 0) {
        if (this.props.onSwipingLeft) {
          this.props.onSwipingLeft(e, pos.absX)
          cancelPageSwipe = true
        }
      } else {
        if (this.props.onSwipingRight) {
          this.props.onSwipingRight(e, pos.absX)
          cancelPageSwipe = true
        }
      }
    } else {
      if (pos.deltaY > 0) {
        if (this.props.onSwipingUp) {
          this.props.onSwipingUp(e, pos.absY)
          cancelPageSwipe = true
        }
      } else {
        if (this.props.onSwipingDown) {
          this.props.onSwipingDown(e, pos.absY)
          cancelPageSwipe = true
        }
      }
    }

    this.setState({ swiping: true })

    if (cancelPageSwipe) {
      e.preventDefault()
    }
  },

  touchEnd: function (ev) {
    if (this.state.swiping) {
      var pos = this.calculatePos(ev)

      var time = Date.now() - this.state.start
      var velocity = Math.sqrt(pos.absX * pos.absX + pos.absY * pos.absY) / time
      var isFlick = velocity > this.props.flickThreshold

      this.props.onSwiped && this.props.onSwiped(
        ev,
        pos.deltaX,
        pos.deltaY,
        isFlick
      )
      
      if (pos.absX > pos.absY) {
        if (pos.deltaX > 0) {
          this.props.onSwipedLeft && this.props.onSwipedLeft(ev, pos.deltaX, isFlick)
        } else {
          this.props.onSwipedRight && this.props.onSwipedRight(ev, pos.deltaX, isFlick)
        }
      } else {
        if (pos.deltaY > 0) {
          this.props.onSwipedUp && this.props.onSwipedUp(ev, pos.deltaY, isFlick)
        } else {
          this.props.onSwipedDown && this.props.onSwipedDown(ev, pos.deltaY, isFlick)
        }
      }
    }
    
    this.setState(this.getInitialState())
  },

  render: function () {
    return (
      React.createElement("div", React.__spread({},  this.props, 
        {onTouchStart: this.touchStart, 
        onTouchMove: this.touchMove, 
        onTouchEnd: this.touchEnd}), 
          this.props.children
      )  
    )
  }
});
        	var Game = React.createClass({
                getInitialState: function(){
                    if(localStorage["2048"]){
                        var initialState = JSON.parse(localStorage["2048"]);
                    }
                    else if(localStorage["2048-best"]){
                        var initialState = {
                            tiles : [
                            ],
                            bestScore: localStorage["2048-best"],
                            score : 0
                        }
                        initialState.tiles = initialState.tiles.concat([
                                this.getRandomTile(initialState.tiles)
                        ])
                        initialState.tiles = initialState.tiles.concat([
                                this.getRandomTile(initialState.tiles)
                        ])
                    }
                    else{
                        var initialState = {
                            tiles : [
                            ],
                            bestScore: 0,
                            score : 0  
                        }
                        initialState.tiles = initialState.tiles.concat([
                                this.getRandomTile(initialState.tiles)
                        ])
                        initialState.tiles = initialState.tiles.concat([
                                this.getRandomTile(initialState.tiles)
                        ])                         
                    }
                    return initialState;
                },
                componentDidMount: function(){
                
                },
                getTilesFromColumn: function(column){
                    return this.state.tiles.filter(function(tile){
                        return tile.x === column
                    })
                },
                getTilesFromLine: function(line){
                    return this.state.tiles.filter(function(tile){
                        return tile.y === line
                    })
                },
                generateNewTile: function(tiles){
                    return tiles = tiles.concat([
                        this.getRandomTile(tiles)
                    ])
                },
                moveButton:function(direction){
                    if(direction){
                        this.move(direction);
                    }
                },
                left:function(){
                    var that = this; 
                    var moved = false;
                    var res;
                    for(var i = 1; i <= 4; i++){
                        var tiles = that.getTilesFromColumn(i);
                        tiles.forEach(function(tile){
                            res = that.moveTileLeft(tile)
                            moved = moved || res;
                        })
                    }
                    if(moved){
                        that.state.tiles = that.generateNewTile(that.state.tiles);
                    }
                    that.state.tiles = _.sortBy(that.state.tiles, function(n){
                        return n.num;
                    })
                    
                    that.setState({tiles : that.state.tiles}) 
                    
                    var array = {
                            tiles : that.state.tiles,
                            bestScore : that.state.bestScore,
                            score : that.state.score
                       }
                    localStorage["2048"] = JSON.stringify(array);
                    this.checkGameOver();
                },
                right:function(){
                    var that = this; 
                    var moved = false;
                    var res;
                    for(var i = 4; i >= 1; i--){
                        var tiles = that.getTilesFromColumn(i)
                        tiles.forEach(function(tile){
                            res = that.moveTileRight(tile)
                            moved = moved || res;
                        })
                    }
                    if(moved){
                        that.state.tiles = that.generateNewTile(that.state.tiles);
                    }
                    that.state.tiles = _.sortBy(that.state.tiles, function(n){
                        return n.num;
                    })
                    
                    that.setState({tiles : that.state.tiles}) 
                    
                    var array = {
                            tiles : that.state.tiles,
                            bestScore : that.state.bestScore,
                            score : that.state.score
                       }
                    localStorage["2048"] = JSON.stringify(array);
                    this.checkGameOver();
                },
                up:function(){
                    var that = this; 
                    var moved = false;
                    var res;
                    for(var i = 1; i <= 4; i++){
                        var tiles = that.getTilesFromLine(i)
                        tiles.forEach(function(tile){
                            res = that.moveTileUp(tile)
                            moved = moved || res;
                        })
                    }
                    if(moved){
                        that.state.tiles = that.generateNewTile(that.state.tiles);
                    }
                    that.state.tiles = _.sortBy(that.state.tiles, function(n){
                        return n.num;
                    })
                    
                    that.setState({tiles : that.state.tiles}) 
                    
                    var array = {
                            tiles : that.state.tiles,
                            bestScore : that.state.bestScore,
                            score : that.state.score
                       }
                    localStorage["2048"] = JSON.stringify(array);
                    this.checkGameOver();
                },
                down:function(){
                    var that = this; 
                    var moved = false;
                    var res;
                    for(var i = 4; i >= 1; i--){
                        var tiles = that.getTilesFromLine(i)
                        tiles.forEach(function(tile){
                            res = that.moveTileDown(tile)
                            moved = moved || res;
                        })
                    }
                    if(moved){
                        that.state.tiles = that.generateNewTile(that.state.tiles);
                    }
                    that.state.tiles = _.sortBy(that.state.tiles, function(n){
                        return n.num;
                    })
                    
                    that.setState({tiles : that.state.tiles}) 
                    
                    var array = {
                            tiles : that.state.tiles,
                            bestScore : that.state.bestScore,
                            score : that.state.score
                       }
                    localStorage["2048"] = JSON.stringify(array);
                    this.checkGameOver();
                },
                move: function(direction){
                    var that = this; 
                    var moved = false;
                    var res;
                    if(direction == "down"){
                        for(var i = 4; i >= 1; i--){
                            var tiles = that.getTilesFromLine(i)
                            tiles.forEach(function(tile){
                                res = that.moveTileDown(tile)
                                moved = moved || res;
                            })
                        }
                    }
                    if(direction == "up"){
                        var res;
                        for(var i = 1; i <= 4; i++){
                            var tiles = that.getTilesFromLine(i)
                            tiles.forEach(function(tile){
                                res = that.moveTileUp(tile)
                                moved = moved || res;
                            })
                        }
                    }
                    if(direction == "right"){
                        for(var i = 4; i >= 1; i--){
                            var tiles = that.getTilesFromColumn(i)
                            tiles.forEach(function(tile){
                                res = that.moveTileRight(tile)
                                moved = moved || res;
                            })
                        }
                    }
                    if(direction == "left"){
                        for(var i = 1; i <= 4; i++){
                            var tiles = that.getTilesFromColumn(i);
                            tiles.forEach(function(tile){
                                res = that.moveTileLeft(tile)
                                moved = moved || res;
                            })
                        }
                    } 
                    if(moved){
                        that.state.tiles = that.generateNewTile(that.state.tiles);
                    }
                    that.state.tiles = _.sortBy(that.state.tiles, function(n){
                        return n.num;
                    })
                    
                    that.setState({tiles : that.state.tiles}) 
                    
                    var array = {
                            tiles : that.state.tiles,
                            bestScore : that.state.bestScore,
                            score : that.state.score
                       }
                    localStorage["2048"] = JSON.stringify(array);
                    this.checkGameOver();         
                },
                moveTileDown: function(tile){
                    if(tile.y != 4){
                        if(this.checkTile(tile.x, tile.y + 1)){
                            if(tile.value == this.getTile(tile.x, tile.y + 1).value){
                                var res = this.mergeTile(tile, this.getTile(tile.x, tile.y + 1));
                                return {'action': 'merge'}
                            }
                            return false
                        } else{
                            tile.y++
                            this.moveTileDown(tile)
                            if(tile.value == this.getTile(tile.x, tile.y + 1).value){
                                var res = this.mergeTile(tile, this.getTile(tile.x, tile.y + 1));
                                return {'action': 'merge'}
                            }
                            return tile
                        }
                    }
                    return false;
                },
                moveTileUp: function(tile){
                    if(tile.y != 1){
                        if(this.checkTile(tile.x, tile.y - 1)){
                            if(tile.value == this.getTile(tile.x, tile.y - 1).value){
                                var res = this.mergeTile(tile, this.getTile(tile.x, tile.y - 1));
                                return {'action': 'merge'}
                            }
                            return false
                        } else{
                            tile.y--
                            this.moveTileUp(tile)
                            if(tile.value == this.getTile(tile.x, tile.y - 1).value){
                                var res = this.mergeTile(tile, this.getTile(tile.x, tile.y - 1));
                                return {'action': 'merge'}
                            }
                            return tile
                        }
                    }
                    return false;
                },
                moveTileRight: function(tile){
                    if(tile.x != 4){
                        if(this.checkTile(tile.x+1, tile.y)){
                            if(tile.value == this.getTile(tile.x+1, tile.y).value){
                                var res = this.mergeTile(tile, this.getTile(tile.x+1, tile.y));
                                return {'action': 'merge'}
                            }
                            return false
                        } else{
                            tile.x++
                            this.moveTileRight(tile)
                            if(tile.value == this.getTile(tile.x+1, tile.y).value){
                                var res = this.mergeTile(tile, this.getTile(tile.x+1, tile.y));
                                return {'action': 'merge'}
                            }
                            return tile
                        }
                    }
                    return false;
                },
                moveTileLeft: function(tile){
                    if(tile.x != 1){
                        if(this.checkTile(tile.x-1, tile.y)){
                            if(tile.value == this.getTile(tile.x-1, tile.y).value){
                                var res = this.mergeTile(tile, this.getTile(tile.x-1, tile.y));
                                return {'action': 'merge'}
                            }
                            return false
                        } else{
                            tile.x--
                            this.moveTileLeft(tile)
                            if(tile.value == this.getTile(tile.x-1, tile.y).value){
                                var res = this.mergeTile(tile, this.getTile(tile.x-1, tile.y));
                                return {'action': 'merge'}
                            }
                            return tile
                        }
                    }
                    return false;
                },
                mergeTile: function(tile1, tile2){
                    var tileValue = tile1.value;
                    var newValue = tileValue * 2;
                    var newScore = this.state.score + newValue;
                    this.setState({score: newScore});
                    if(newScore > this.state.bestScore){
                        this.setState({bestScore: newScore});
                    }
                    newValue = newValue.toString();
                    this.state.tiles = this.state.tiles.filter(function(tile){
                        if(tile.num == tile1.num || tile.num == tile2.num){
                            return false
                        }else{
                            return true
                        }
                    })
                    var maxTile = _.maxBy(this.state.tiles, function(o) { return o.num; }) || {num: 0};
                    var mergedTile = {'value': newValue, num: maxTile.num + 1, 'x': tile2.x, 'y': tile2.y, merged: true}
                    this.state.tiles = this.state.tiles.concat(mergedTile);
                },
                checkTile : function(x, y){
                    for(var i = 0; i < this.state.tiles.length; i++){
                        if(this.state.tiles[i].x == x && this.state.tiles[i].y == y) return true
                    }
                    return false
                },
                getTile : function(x, y){
                    for(var i = 0; i < this.state.tiles.length; i++){
                        if(this.state.tiles[i].x == x && this.state.tiles[i].y == y) return this.state.tiles[i]
                    }
                    return false
                },
                getRandomTile: function(tiles){
                    tiles = this.state ? this.state.tiles : tiles; 
                    var xRand = Math.floor(Math.random() * 4) + 1;
                    var yRand = Math.floor(Math.random() * 4) + 1;
                    var initial = ['2', '4'];
                    var nbRand = initial[Math.floor(Math.random() * (2 - 0) + 0)];
                    var filterTile = tiles.filter(function(tile) {
                        return xRand === tile.x && yRand === tile.y
                    });
                    if(filterTile.length > 0){
                        return this.getRandomTile(tiles)
                    }
                    var maxTile = _.maxBy(tiles, function(o) { return o.num; }) || {num: 0};
                    return {'value': nbRand, num: maxTile.num + 1, 'x': xRand, 'y': yRand} 
                },
                getGrid: function(){
                    return(
                        [0, 1, 2, 3].map(function(x){
                            return(
                                <div className="grid-row" key={x}>
                                {
                                    [0, 1, 2, 3].map(function(y){
                                       return <div className="grid-cell" key={x + "-" + y}></div>
                                    })
                                }
                                </div>
                            )
                        })
                    )
                },
                retry: function(){
                    var elems =  document.getElementsByClassName("game-message");
                    for (var i=0;i<elems.length;i+=1){
                      elems[i].style.display = 'none';
                    }
                    localStorage["2048-best"] = this.state.bestScore;
                    localStorage.removeItem('2048');
                    this.state = null;
                    this.setState(this.getInitialState())
                },
                checkGameOver: function(){
                    if(!this.movesAvailable()){
                        console.log("game over")
                        var elems =  document.getElementsByClassName("game-message");
                        for (var i=0;i<elems.length;i+=1){
                          elems[i].style.display = 'block';
                        }
                    }else{
                        return false;
                    }
                },
                getVector :function (direction) {
                  var map = {
                    0: { x: 0,  y: -1 }, // Up
                    1: { x: 1,  y: 0 },  // Right
                    2: { x: 0,  y: 1 },  // Down
                    3: { x: -1, y: 0 }   // Left
                  };
                  return map[direction];
                },
                movesAvailable: function(){
                    if(this.state.tiles.length >= 16){
                        var tile;
                        for(var i = 1; i < 5; i++){
                            for(var j = 1; j < 5; j++){
                                tile = this.getTile(i, j);
                                if (tile) {
                                    for (var direction = 0; direction < 4; direction++) {
                                        var vector = this.getVector(direction);
                                        var other  = this.getTile(i + vector.x, j + vector.y);
                                        if (other.value == tile.value) {
                                            return true;
                                        }
                                    }
                                }
                            }
                        }
                        return false;
                    } else {
                        return true
                    }
                },
        		render: function(){
                    var tilepositions = this.state.tiles.map(function(tile){
                        return tile.x + " " + tile.y;
                    })
                    if(_.uniq(tilepositions).length !== tilepositions.length){
                        throw new Error("doublon")
                    }
                    var divStyle = {
                      display: 'none'
                    };
                    return(
                        <Swipeable
        onSwipedUp={this.up}
        onSwipedRight={this.right}
        onSwipedDown={this.down}
        onSwipedLeft={this.left}>
                            <div className="heading">
                                <div className="scores-container">
                                    <div className="score-container">
                                        {this.state.score}
                                    </div>
                                    <div className="best-container">{this.state.bestScore}</div>
                                </div>
                            </div>
                            <div className="above-game">
                                <p className="game-intro">Fusionne les cases pour arriver à<strong> 2048</strong></p>
                                <a className="restart-button" onClick={this.retry}>Rejouer</a>
                            </div>
                            <div className="game-container">
                                <div className="game-message game-over" style={divStyle}>
                                    <p>Tu as perdu !</p>
                                    <div className="lower">
                                        <a className="retry-button" onClick={this.retry}>Recommence !</a>
                                    </div>
                                </div>
                                <div className="grid-container">
                                    { this.getGrid() }
                                </div>
                                <div className="tile-container" key="tile-container">
                                {
                                    this.state.tiles.map(function(tile, i){
                                        var style = "tile tile-"+ tile.value +" tile-position-"+ tile.x +"-"+ tile.y
                                        return(
                                            <div className={style} key={tile.num}>
                                                <div className="tile-inner">{tile.value}</div>
                                            </div>
                                        )
                                    }.bind(this))
                                }
                                </div>
                             </div>
                        </Swipeable>
        			)
        		}
        	});
        	ReactDOM.render(
        		<Game />,
        		document.getElementById('game')
        	);
        </script>
    </body>
</html>